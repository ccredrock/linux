#[排序算法](../code/sum_sort_algorithm.c)

##冒泡排序
* 理论:迭代比较相邻记录
* 时间复杂度: O(n) ~ O(n^2)
* 稳定

##插入排序
* 理论:插入到已排序记录
* 时间复杂度: O(n) ~ O(n^2)
* 稳定

##选择排序
* 理论:选择极值放入已排序尾
* 时间复杂度: O(n^2) ~ O(n^2)
* 不稳定:5 8 5 2 9 => 2 8 5 5 9

##归并排序
* 理论:归并 左右排序
* 时间复杂度: O(nlogn) ~ O(nlogn)
* 稳定

##快速排序
* 理论:拆分 中心两侧排序
* 时间复杂度: O(nlogn) ~ O(n^2)
* 不稳定:5 3 3 4 3 8 9 10 11 => 3 5 3 4 3 8 9 10 11

##堆排序
* 理论:创建最大堆 循环提取最大数
* 时间复杂度: O(nlogn) ~ O(nlogn)
* 不稳定:创建最大堆 9 3 6 2 6 -> 9 6 6 2 3

##计数排序
* 理论:用key值直接确定排序位置
* 时间复杂度:O(n+k)
* 不定

##桶排序
* 理论:用key值将数据分成多个桶
* 时间复杂度:O(n + nlogn - nlogm) ~ O(n)
* 不定

##基数排序
* 理论:用key值计算新的key值进行多次排序
* 时间复杂度: O(d(rd+n)) ~ O(d(rd+n))
* 稳定

##希尔排序

##链接
* http://blog.csdn.net/jnu_simba/article/details/9705111
* https://www.oschina.net/question/565065_86352

##基于排序算法最优复杂度 NlogN
* N个元素 未排序 有N!种排序结果
* N个元素 经过M次排序 有N!/2种排序结果
* 排序最后 N!/(2^M) <= 1
* 斯特林公式 推算 M >= NlogN

